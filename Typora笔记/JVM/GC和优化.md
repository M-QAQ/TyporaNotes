[TOC]



# 1.Minor GC、Major GC、Full GC

JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代:方法区)区域一起回收的，大部分时候回收的都是指新生代。
针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型:一 种是部分收集(Partial GC)，一种是整堆收集(Full GC)。

- 部分收集:不是完整收集整个Java堆的垃圾收集。其中又分为:

  - 新生代收集(Minor GC / Young GC) :只是新生代(Eden\S0,S1) 的垃圾收集。

  - 老年代收集(Major GC / 0ld GC) :只是老年代的垃圾收集。
    - 目前， 只有CMS GC会有单独收集老年代的行为。
    - **注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收**。

  - 混合收集(Mixed GC):收集整个新生代以及部分老年代的垃圾收集。
    - 目前，只有G1 GC会有这种行为。

- 整堆收集(Full GC):收集整个java堆和方法区的垃圾收集。

### 1.1年轻代GC触发机制

- 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。 (每次 Minor GC会清理年轻代的内存。)
- 因为Java对象**大多都具备朝生夕灭**的特性，所以MinorGC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。
- Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。

### 1.2老年代GC触发机制

- 指发生在 老年代的GC，对象从老年代消失时，我们说“Major GC" 或“Full GC”发生了。
- 出现了Major GC，经常会伴随至少一次的Minor GC (但非绝对的，在Paral1el Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。
  - 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC
- Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。
- 如果Major GC后，内存还不足，就报OOM了。

### 1.3Full GC触发机制

触发Full GC执行的情况有如下五种:

1. 调用System. gc()时，系统建议执行Fu1l GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、survivor space0 (From Space)区向survivor space1 (To Space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小.

说明: **full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。**



# 2.什么是垃圾？

### 2.1引用计数器法

### 2.2 可达性分析算法

- 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。
- 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集(Tracing GarbageCollection)

#### 什么是可达性分析算法？

- 可达性分析算法是以根对象集合(GC Roots) 为起始点，按照从上至下I的方式搜索被根对象集合所连接的目标对象是否可达。
- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)
- 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
- 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

![image-20200623221834699](GC%E5%92%8C%E4%BC%98%E5%8C%96.assets/image-20200623221834699.png)

#### GC Roots有哪些元素？

1. 虚拟机栈中引用的对象

   ➢比如:各个线程被调用的方法中使用到的参数、局部变量等。

2. 本地方法栈内JNI (通常说的本地方法)引用的对象

3. 方法区中类静态属性引用的对象
   ➢比如: Java类的引用类型静态变量

4. 方法区中常量引用的对象
   ➢比如:字符串常量池(String Table)里的引用

5. 所有被同步锁synchroni zed持有的对象

6. Java虚拟机内部的引用。
   ➢基本数据类型对应的Class对象，- -些常驻的异常对象(如: NullPointe rException、OutOfMemoryError)，系统类加载器。

7. 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

8. 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如:分代收集和局部回收(Partial GC)。

   ➢如果只针对Java堆中的某-块区域进行垃圾回收(比如:典型的只针对新生代)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。

小技巧:

由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。

如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。

这点也是导致GC进行时必须"Stop The world"的一个重要原因。即使是号称(几乎)不会发生停顿的CMS收集器中，**枚举根节点时也是必须要停顿的**。