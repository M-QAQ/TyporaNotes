### 相关查询SQL

【看看哪些表被加锁了】

```mysql
mysql>show open tables;
```

【如何分析表锁定】
可以通过检查table_locks_waited和table_locks_immediate状态变量来分析 系统上的表锁定: 

```mysql
SQL: show status like 'table%';
```

这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下:
	Table_locks_immediate: 产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1 ;
	Table_locks_waited:出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1)，此值高则说明存在着较严重的表级锁争用情况;

**此外，Myisam的读写锁调度是写优先，这也是myisam不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞**

### MyISAM（表锁 偏读）

​	MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。

​	MySql的表级锁有两种模式：

​			表共享读锁（table read lock）

​			表独占写锁（table write lock）

| 锁类型 | 可否兼容 | 读锁 | 写锁 |
| ------ | -------- | ---- | ---- |
| 读锁   | 是       | 是   | 否   |
| 写锁   | 是       | 否   | 否   |

​	结论：

​	结合上表，对MyISAM表进行操作，会有以下情况：

	1. 对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程的写操作。
 	2. 对MyISAM表的写操作（加写锁），会阻塞其他线程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。

**简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会读和写都阻塞。**

### InnoDB（行锁 偏写）

##### 特点：

​		InnoDB与MyISAM最大的不同有两点：一是支持事务；二是采用了行级锁

##### 事务：

​		事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。

> 原子性(Atomicity) :事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
> 一致性(Consistent) :在事务开始和完成时，数据都必须保持一 致状态。这意味着所有相关的数据规则都必须应用于事务的修改以保持数据的完整性;事务结束时，所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。
> 隔离性(Isolation) :数据库系统提供- -定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
> 持久性(Durable) :事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

##### 事务隔离级别：

脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。

| 读数据一致性及允许的并发副作用隔离级别 | 读数据一致性                             | 脏读 | 不可重复读 | 幻读 |
| -------------------------------------- | ---------------------------------------- | ---- | ---------- | ---- |
| 未提交读（Read uncommitted）           | 最低级别，只能保证不读取物理上损坏的数据 | 是   | 是         | 是   |
| 已提交读（Read committed）             | 语句级                                   | 否   | 是         | 是   |
| 可重复读（Repeatable read）            | 事务级                                   | 否   | 否         | 是   |
| 可序列表（Seriaizable）                | 最高级别，事务级                         | 否   | 否         | 否   |

数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。

常看当前数据库的事务隔离级别: 

```mysql
show variables like 'tx_isolation';
```



索引失效导致行锁变表锁；

间隙锁：

【什么是间隙锁】
当我们用范围除件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给 符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)” ，
InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁) 。

【危害】
因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。
间隙锁有一个比较致命的弱点，就是当锁定-一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害